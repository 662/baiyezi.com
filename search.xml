<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>仅用两行代码实现笛卡尔积，高效解决商品类型组合问题</title>
      <link href="/2020/09/01/cartesian-product/"/>
      <url>/2020/09/01/cartesian-product/</url>
      
        <content type="html"><![CDATA[<p>笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尔积（Cartesian product），又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在程序设计领域笛卡尔乘积多用于多个属性组合描述某事物，例如在线购物时通过颜色、容量、重量来选择一部手机：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = [</span><br><span class="line">  [<span class="string">'红'</span>, <span class="string">'黄'</span>, <span class="string">'蓝'</span>],</span><br><span class="line">  [<span class="string">'64G'</span>, <span class="string">'128G'</span>, <span class="string">'256G'</span>],</span><br><span class="line">  [<span class="string">'30kg'</span>, <span class="string">'100kg'</span>, <span class="string">'5kg'</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我们可以通过该数组组合得到 <strong>红-128G-100kg</strong> 这样一台手机，该数组可以组合出 27 种不同的配置，那么这个组合的过程我们就可以用笛卡尔乘积来处理。</p><h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><p>首先申明笛卡尔乘积函数，用于将两个一维数组进行组合：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cartesianProduct = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> prev.reduce(<span class="function">(<span class="params">result, p</span>) =&gt;</span> [...result, ...next.map(<span class="function"><span class="params">n</span> =&gt;</span> p + n)], [])</span><br></pre></td></tr></table></figure><p>然后遍历数据源，将数组种的前两个元素带入到上面的函数得出一个新的数组，再把得到的数组与第三个元素带入，以此迭代得到最终的结果:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source.reduce(<span class="function">(<span class="params">result, item, i</span>) =&gt;</span> (i &gt; <span class="number">0</span> ? cartesianProduct(result, item) : result), source[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>得益于 <code>javascript</code> 对数组操作的便利性，我们可以写出比大多数语言都要少量的代码</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = [</span><br><span class="line">  [<span class="string">'红'</span>, <span class="string">'黄'</span>, <span class="string">'蓝'</span>],</span><br><span class="line">  [<span class="string">'64G'</span>, <span class="string">'128G'</span>, <span class="string">'256G'</span>],</span><br><span class="line">  [<span class="string">'4C'</span>, <span class="string">'8C'</span>, <span class="string">'16C'</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cartesianProduct = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> prev.reduce(<span class="function">(<span class="params">result, p</span>) =&gt;</span> [...result, ...next.map(<span class="function"><span class="params">n</span> =&gt;</span> p + n)], [])</span><br><span class="line"><span class="keyword">const</span> r = source.reduce(<span class="function">(<span class="params">result, item, i</span>) =&gt;</span> (i &gt; <span class="number">0</span> ? cartesianProduct(result, item) : result), source[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r)</span><br></pre></td></tr></table></figure><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p><img src="https://cdn.jsdelivr.net/gh/662/cdn-blog/post/2020-09-02-09-41-50.png" alt=""></p><h3 id="结果二维数组版"><a href="#结果二维数组版" class="headerlink" title="结果二维数组版"></a>结果二维数组版</h3><blockquote><p>更新于 2022-03-04</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cartesianProduct = <span class="function"><span class="params">s</span> =&gt;</span> s.reduce(<span class="function">(<span class="params">p, c, i</span>) =&gt;</span> i &gt; <span class="number">0</span> ? p.reduce(<span class="function">(<span class="params">r, p</span>) =&gt;</span> r.concat(c.map(<span class="function"><span class="params">n</span> =&gt;</span> [p].flat().concat(n))), []) : c.map(<span class="function"><span class="params">n</span> =&gt;</span> [n]), [])</span><br></pre></td></tr></table></figure><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> cartesianProduct = <span class="function"><span class="params">s</span> =&gt;</span> s.reduce(<span class="function">(<span class="params">p, c, i</span>) =&gt;</span> i &gt; <span class="number">0</span> ? p.reduce(<span class="function">(<span class="params">r, p</span>) =&gt;</span> r.concat(c.map(<span class="function"><span class="params">n</span> =&gt;</span> [p].flat().concat(n))), []) : c.map(<span class="function"><span class="params">n</span> =&gt;</span> [n]), [])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cartesianProduct([</span><br><span class="line">  [<span class="string">'粉'</span>, <span class="string">'黄'</span>, <span class="string">'蓝'</span>],</span><br><span class="line">  [<span class="string">'64G'</span>, <span class="string">'128G'</span>, <span class="string">'256G'</span>],</span><br><span class="line">  [<span class="string">'4C'</span>, <span class="string">'8C'</span>, <span class="string">'16C'</span>],</span><br><span class="line">]))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'-----分割线------'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(cartesianProduct([[<span class="string">'粉'</span>, <span class="string">'黄'</span>, <span class="string">'蓝'</span>]]))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br><span class="line">[</span><br><span class="line">  [ <span class="string">'粉'</span>, <span class="string">'64G'</span>, <span class="string">'4C'</span> ],   [ <span class="string">'粉'</span>, <span class="string">'64G'</span>, <span class="string">'8C'</span> ],</span><br><span class="line">  [ <span class="string">'粉'</span>, <span class="string">'64G'</span>, <span class="string">'16C'</span> ],  [ <span class="string">'粉'</span>, <span class="string">'128G'</span>, <span class="string">'4C'</span> ],</span><br><span class="line">  [ <span class="string">'粉'</span>, <span class="string">'128G'</span>, <span class="string">'8C'</span> ],  [ <span class="string">'粉'</span>, <span class="string">'128G'</span>, <span class="string">'16C'</span> ],</span><br><span class="line">  [ <span class="string">'粉'</span>, <span class="string">'256G'</span>, <span class="string">'4C'</span> ],  [ <span class="string">'粉'</span>, <span class="string">'256G'</span>, <span class="string">'8C'</span> ],</span><br><span class="line">  [ <span class="string">'粉'</span>, <span class="string">'256G'</span>, <span class="string">'16C'</span> ], [ <span class="string">'黄'</span>, <span class="string">'64G'</span>, <span class="string">'4C'</span> ],</span><br><span class="line">  [ <span class="string">'黄'</span>, <span class="string">'64G'</span>, <span class="string">'8C'</span> ],   [ <span class="string">'黄'</span>, <span class="string">'64G'</span>, <span class="string">'16C'</span> ],</span><br><span class="line">  [ <span class="string">'黄'</span>, <span class="string">'128G'</span>, <span class="string">'4C'</span> ],  [ <span class="string">'黄'</span>, <span class="string">'128G'</span>, <span class="string">'8C'</span> ],</span><br><span class="line">  [ <span class="string">'黄'</span>, <span class="string">'128G'</span>, <span class="string">'16C'</span> ], [ <span class="string">'黄'</span>, <span class="string">'256G'</span>, <span class="string">'4C'</span> ],</span><br><span class="line">  [ <span class="string">'黄'</span>, <span class="string">'256G'</span>, <span class="string">'8C'</span> ],  [ <span class="string">'黄'</span>, <span class="string">'256G'</span>, <span class="string">'16C'</span> ],</span><br><span class="line">  [ <span class="string">'蓝'</span>, <span class="string">'64G'</span>, <span class="string">'4C'</span> ],   [ <span class="string">'蓝'</span>, <span class="string">'64G'</span>, <span class="string">'8C'</span> ],</span><br><span class="line">  [ <span class="string">'蓝'</span>, <span class="string">'64G'</span>, <span class="string">'16C'</span> ],  [ <span class="string">'蓝'</span>, <span class="string">'128G'</span>, <span class="string">'4C'</span> ],</span><br><span class="line">  [ <span class="string">'蓝'</span>, <span class="string">'128G'</span>, <span class="string">'8C'</span> ],  [ <span class="string">'蓝'</span>, <span class="string">'128G'</span>, <span class="string">'16C'</span> ],</span><br><span class="line">  [ <span class="string">'蓝'</span>, <span class="string">'256G'</span>, <span class="string">'4C'</span> ],  [ <span class="string">'蓝'</span>, <span class="string">'256G'</span>, <span class="string">'8C'</span> ],</span><br><span class="line">  [ <span class="string">'蓝'</span>, <span class="string">'256G'</span>, <span class="string">'16C'</span> ]</span><br><span class="line">]</span><br><span class="line">-----分割线------</span><br><span class="line">[ [ <span class="string">'粉'</span> ], [ <span class="string">'黄'</span> ], [ <span class="string">'蓝'</span> ] ]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code snippet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统下使用 iptables 进行流量限制</title>
      <link href="/2020/01/06/iptables-bandwidth-usage-throttle/"/>
      <url>/2020/01/06/iptables-bandwidth-usage-throttle/</url>
      
        <content type="html"><![CDATA[<p>日常在售的大口子 VPS 套餐很多都有流量限制，预付费的还好，流量用完之后就会有类似停机的保护策略，可后付费就有点危险了，以阿里云国际版新手套餐 2.0 为例，网友笑称当流量包用完之后可以一夜跑掉一套房。</p><p>所以我们使用 Linux 系统下的一大杀器 iptables 来限制我们的流量开销，当流量达到阈值时就不再相应请求，以此来避免一夜回到解放前的尴尬局面。</p><a id="more"></a><h3 id="iptables-命令回顾"><a href="#iptables-命令回顾" class="headerlink" title="iptables 命令回顾"></a>iptables 命令回顾</h3><p>我们先来回顾一下 iptables 的基础知识</p><p>iptables 结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Table &#123;</span><br><span class="line">    Chain &#123;</span><br><span class="line">        Rule &#123;</span><br><span class="line">            (match, match, ...)</span><br><span class="line">            target</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iptables 规则语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ iptables      &lt;指定链和操作-chain&gt;        &lt;指定匹配规则-match&gt;        &lt;指定匹配后的操作-target&gt;</span><br><span class="line">// 示例：</span><br><span class="line">$ iptables      -A OUTPUT                  -m tcp -dport 80           -j ACCEPT</span><br></pre></td></tr></table></figure><h3 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h3><h4 id="规则编写"><a href="#规则编写" class="headerlink" title="规则编写"></a>规则编写</h4><p>根据 iptables 的使用方法，我们可以很轻易的写出一个限制流量的规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -A OUTPUT -p tcp -m quota --quota 1024000 -j ACCEPT</span><br><span class="line">$ iptables -A OUTPUT -p tcp -j DROP</span><br></pre></td></tr></table></figure><h4 id="规则解释"><a href="#规则解释" class="headerlink" title="规则解释"></a>规则解释</h4><ul><li><code>-A OUTPUT</code> 代表在 OUTPUT 链中添加一条规则，OUTPUT 是 iptables 规则中的一个链(Chain)，代表流出的流量包，总共有三个(INPUT, FORWARD, OUTPUT)，区分不同场景的规则；</li><li><code>-p tcp</code> 是iptables的协议参数 <code>--protocol</code>，匹配规则的一部分；</li><li><code>-m quota --quota 1024000</code> 是该条规则的另一匹配规则(match)，匹配通过则执行后面指定的操作(target)。这里用 <code>quota</code> 做匹配，限制1M流量(1024000 Bytes)；</li><li><code>-j ACCEPT</code> 指定匹配成功后的执行操作，<code>ACCEPT</code> 代表接受，<code>DROP</code> 代表丢弃包；</li></ul><p>这两条规则合起来：</p><p>第一条指定：对于流出的tcp协议包，如果流量没有超过限制，则允许通过。</p><p>当第一条规则匹配失败，即流量超过后，顺序第二条规则生效。第二条规则指定：拒绝所有的tcp协议流出包。</p><p>两者合起来，流量限制内通过，流量超出后拒绝，达到控制流量的目的。</p><p>另，针对tcp端口匹配有两种：<code>–sport</code>, <code>–dport</code>，其区别是包的连接两段的方向</p><ul><li><code>--sport</code>，source port，指定连接的来源段</li><li><code>--dport</code>，destination port，指定链接的目的端</li></ul><h3 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a>完整版</h3><p>基础版中 iptables 规则限制了我们的流量为 1M，超出 1M 后我们的服务器就 GG 了，这显然不是我们想要的效果。</p><p>我们需要的是以月为单位进行流量控制，单月超标之后禁止流量流出，下月重新计算。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除链：throttle1t</span></span><br><span class="line">iptables -F throttle1t</span><br><span class="line">iptables -F OUTPUT</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建链：throttle1t</span></span><br><span class="line">iptables -N throttle1t</span><br><span class="line"><span class="comment"># 1020054732800 = 1024 * 1024 * 1024 * 950 = 950GB</span></span><br><span class="line">iptables -A throttle1t -m quota --quota 1020054732800 -j RETURN</span><br><span class="line">iptables -A throttle1t -j DROP</span><br><span class="line"></span><br><span class="line">iptables -A OUTPUT -o eth0+ -j throttle1t</span><br></pre></td></tr></table></figure><p>在配合 crontab 每月 1 号 0 点 0 分定时重置计数器即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 * * &#x2F;sbin&#x2F;iptables -Z throttle1t</span><br></pre></td></tr></table></figure><p>这样我们就可安心的使用流量了~</p>]]></content>
      
      
      <categories>
          
          <category> ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> iptables </tag>
            
            <tag> firewall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用微软 RPA 自动同步 OneDrive 内容到 Google Drive</title>
      <link href="/2019/11/13/googledrive-to-onedrive/"/>
      <url>/2019/11/13/googledrive-to-onedrive/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>现在随处可见的 OneDirve 1T/5T/25T 以及 GoogleDrive 无限空间的账号，当这些巨头用各种渠道让用户免费获取大容量存储空间的同时我们自己心里也要明白：我们才是别人种下的韭菜，所以在收割与反收割的博弈当中我们需要给自己留好退路。</p><p>永远不要把鸡蛋放在同一个篮子中，当你手里有一大堆大容量网盘的时候，让他们保持同步是对数据最大的保护。</p><p>目前主流的方案是使用 rclone 之类的同步程序进行跨平台同步数据，亦或是使用一些云服务商提供的数据迁移服务，本文不讨论优劣，只提供另外一条可选路径。</p><h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><ol><li><p>登录<a href="https://flow.microsoft.com/" target="_blank" rel="noopener">微软RPA</a></p></li><li><p>在顶部的搜索框中搜索 Google Drive<br><img src="https://user-images.githubusercontent.com/13599186/75163082-97e08100-5759-11ea-9437-ea3829c11bcf.png" alt=""></p></li><li><p>根据账号类型选择 OneDrive for Business 或是 OneDrive （本文使用 OneDrive for Business）</p></li><li><p>分别点击 OneDrive 和 Google Drive 的登录按钮进行授权<br><img src="https://user-images.githubusercontent.com/13599186/75163125-aaf35100-5759-11ea-92e3-eca1e9ab8da1.png" alt=""></p></li><li><p>完成之后点击“继续”，这样我们就基于“OneDrive for Business 文件到 Google Drive 文件”模板创建了我们自己的流</p></li><li><p>配置流，监听 OneDrive 根目录的文件创建，并在 Google Drive 的相同路径创建相同的文件<br><img src="https://user-images.githubusercontent.com/13599186/75163233-d8d89580-5759-11ea-8225-2685353946f0.png" alt=""><br>由于 OneDrive 创建文件时给出的路径包含了类似<code>/drives/xxxxxxxxxxxxxxxxxxxxxxx/root:</code>这样的用户目录，所以我们要使用函数处理掉这些路径<br><img src="https://user-images.githubusercontent.com/13599186/75163253-df670d00-5759-11ea-82b0-6b9f259c2c65.png" alt=""></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace(replace(replace(decodeBase64(triggerOutputs()[<span class="string">'headers/x-ms-file-path-encoded'</span>]),substring(decodeBase64(triggerOutputs()[<span class="string">'headers/x-ms-file-path-encoded'</span>]), <span class="number">0</span>, lastIndexOf(decodeBase64(triggerOutputs()[<span class="string">'headers/x-ms-file-path-encoded'</span>]), <span class="string">'root:'</span>)),<span class="string">''</span>),<span class="string">'root:'</span>,<span class="string">''</span>), decodeBase64(triggerOutputs()[<span class="string">'headers/x-ms-file-name-encoded'</span>]), <span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>格式化之后是这样，整体思路就是移除<code>/drives/xxxxxxxxxxxxxxxxxxxxxxx/root:</code>以及路径中的文件名，产生真实的用户网盘路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">replace(</span><br><span class="line">  replace(</span><br><span class="line">    replace(</span><br><span class="line">      decodeBase64(triggerOutputs()[<span class="string">'headers/x-ms-file-path-encoded'</span>]),</span><br><span class="line">      substring(</span><br><span class="line">        decodeBase64(triggerOutputs()[<span class="string">'headers/x-ms-file-path-encoded'</span>]),</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        lastIndexOf(decodeBase64(triggerOutputs()[<span class="string">'headers/x-ms-file-path-encoded'</span>]), <span class="string">'root:'</span>),</span><br><span class="line">      ),</span><br><span class="line">      <span class="string">''</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'root:'</span>,</span><br><span class="line">    <span class="string">''</span>,</span><br><span class="line">  ),</span><br><span class="line">  decodeBase64(triggerOutputs()[<span class="string">'headers/x-ms-file-name-encoded'</span>]),</span><br><span class="line">  <span class="string">''</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>配置好了之后可以点击“测试”按钮进行测试，测试过程中能看到 OneDrive 端的相应信息，包含 <code>header</code> 和 <code>body</code> 两部分，<code>header</code>中存放了文件名、路径的信息，<code>body</code>中存放了文件内容、内容类型等信息<br><img src="https://user-images.githubusercontent.com/13599186/75163782-c01caf80-575a-11ea-917a-ef0cfe8410f6.png" alt=""></p></li><li><p>使用过程中随时可以在 我的流 &gt; 运行状态 中查看运行日志，每一条都可以点击查看到详情，详情如 7 所描述<br><img src="https://user-images.githubusercontent.com/13599186/75163292-ee4dbf80-5759-11ea-81e1-0c13c26d2935.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> googledrive </tag>
            
            <tag> onedrive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拐弯抹角使用Google搜索技术资料</title>
      <link href="/2019/01/02/create-v2-server/"/>
      <url>/2019/01/02/create-v2-server/</url>
      
        <content type="html"><![CDATA[<p>自家用潦草笔记，只列大纲，不列过程。</p><p>目标： <code>WebSocket+TLS -&gt; nginx -&gt; V2Ray</code></p><p>所需物资：</p><ul><li>在网 vps</li><li>域名</li><li><a href="http://nginx.org/" target="_blank" rel="noopener">nginx</a></li><li><a href="https://github.com/Neilpang/acme.sh" target="_blank" rel="noopener">acme.sh</a></li><li><a href="https://www.v2ray.com" target="_blank" rel="noopener">V2Ray</a></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="V2Ray"><a href="#V2Ray" class="headerlink" title="V2Ray"></a>V2Ray</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br></pre></td></tr></table></figure><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>直接用<a href="http://nginx.org/en/linux_packages.html" target="_blank" rel="noopener">官方 Packages</a>安装</p><h4 id="acme-sh"><a href="#acme-sh" class="headerlink" title="acme.sh"></a>acme.sh</h4><p>参照<a href="https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">中文文档</a>，4 步搞定：安装 acme.sh -&gt; 生成证书 -&gt; 安装证书 -&gt; 配置自更新</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="V2Ray-1"><a href="#V2Ray-1" class="headerlink" title="V2Ray"></a>V2Ray</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;inbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;listen&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">      &quot;port&quot;: 11111, &#x2F;&#x2F; 监听的端口</span><br><span class="line">      &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;clients&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;id&quot;: &quot;&quot;, &#x2F;&#x2F; uuid</span><br><span class="line">            &quot;alterId&quot;: 64</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;streamSettings&quot;: &#123;</span><br><span class="line">        &quot;network&quot;: &quot;ws&quot;,</span><br><span class="line">        &quot;wsSettings&quot;: &#123;</span><br><span class="line">          &quot;path&quot;: &quot;&#x2F;path&quot; &#x2F;&#x2F; websocket 地址</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;outbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;freedom&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Nginx-1"><a href="#Nginx-1" class="headerlink" title="Nginx"></a>Nginx</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>        your.cer.path;     <span class="comment"># 证书 .cer 路径</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>    your.key.path;     <span class="comment"># 证书 .key 路径</span></span><br><span class="line">    <span class="attribute">ssl_protocols</span>         TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span>           HIGH:!aNULL:!MD5;</span><br><span class="line">    <span class="attribute">server_name</span>  yourdomain;    <span class="comment"># 域名</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> your-web-root;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /yourpath &#123;    <span class="comment"># websocket 地址</span></span><br><span class="line">        <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:your-port;  <span class="comment"># 监听的端口</span></span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">"upgrade"</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ladder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Ubuntu/Debian/Arch 中使用 UFW</title>
      <link href="/2018/05/02/ufw/"/>
      <url>/2018/05/02/ufw/</url>
      
        <content type="html"><![CDATA[<p>UFW，即简单防火墙（uncomplicated firewall），是一个 Arch Linux、Debian 或 Ubuntu 中管理防火墙规则的前端。</p><a id="more"></a><h3 id="安装-UFW"><a href="#安装-UFW" class="headerlink" title="安装 UFW"></a>安装 UFW</h3><p>UFW 默认包含在 Ubuntu 中，但在 Arch 和 Debian 中需要安装。 Debian 将自动启用 UFW 的 systemd 单元，并使其在重新启动时启动，但 Arch 不会。 这与告诉 UFW 启用防火墙规则不同，因为使用 systemd 或者 upstart 启用 UFW 仅仅是告知 init 系统打开 UFW 守护程序。</p><p>默认情况下，UFW 的规则集为空，因此即使守护程序正在运行，也不会强制执行任何防火墙规则。 强制执行防火墙规则集的部分在下面。</p><h4 id="Arch-Linux"><a href="#Arch-Linux" class="headerlink" title="Arch Linux"></a>Arch Linux</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo pacman -S ufw</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">sudo systemctl start ufw</span><br><span class="line"><span class="comment"># 开机自启</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> ufw</span><br></pre></td></tr></table></figure><h4 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Debian 将自动启用 systemd</span></span><br><span class="line">sudo apt-get install ufw</span><br></pre></td></tr></table></figure><h3 id="使用-UFW-管理防火墙规则"><a href="#使用-UFW-管理防火墙规则" class="headerlink" title="使用 UFW 管理防火墙规则"></a>使用 UFW 管理防火墙规则</h3><blockquote><p>警告：</p><p>除非明确设置允许规则，否则配置默认 <code>deny</code> 或 <code>reject</code> 规则会锁定服务器。确保在应用默认 <code>deny</code> 或 <code>reject</code> 规则之前，已按照下面的部分配置了 SSH 和其他关键服务的允许规则。</p></blockquote><h4 id="添加规则"><a href="#添加规则" class="headerlink" title="添加规则"></a>添加规则</h4><p>可以有两种方式添加规则：用端口号或者服务名表示。</p><p>例如：要允许 SSH 的 22 端口的传入和传出连接，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow ssh</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">sudo ufw allow 22</span><br></pre></td></tr></table></figure><p>为了更好地调整规则，也可以允许基于 TCP 或者 UDP 的包。下面例子会允许 80 端口的 TCP 包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 80/tcp</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">sudo ufw allow http/tcp</span><br></pre></td></tr></table></figure><p>这个会允许 1725 端口上的 UDP 包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 1725/udp</span><br></pre></td></tr></table></figure><h4 id="高级规则"><a href="#高级规则" class="headerlink" title="高级规则"></a>高级规则</h4><p>除了基于端口的允许或阻止，UFW 还允许您按照 IP 地址、子网和 IP 地址/子网/端口的组合来允许/阻止。</p><p>允许从一个 IP 地址连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow from 123.45.67.89</span><br></pre></td></tr></table></figure><p>允许特定子网的连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow from 123.45.67.89/24</span><br></pre></td></tr></table></figure><p>允许特定 IP/ 端口的组合：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow from 123.45.67.89 to any port 22 proto tcp</span><br></pre></td></tr></table></figure><p><strong><code>proto tcp</code> 可以删除或者根据需求改成 <code>proto udp</code>，所有例子的 <code>allow</code> 都可以根据需要变成 <code>deny</code>。</strong></p><h4 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h4><p>要删除一条规则，在规则的前面加上 delete。如果希望不再允许 HTTP 流量，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw delete allow 80</span><br></pre></td></tr></table></figure><h3 id="编辑-UFW-的配置文件"><a href="#编辑-UFW-的配置文件" class="headerlink" title="编辑 UFW 的配置文件"></a>编辑 UFW 的配置文件</h3><p>虽然可以通过命令行添加简单的规则，但仍有可能需要添加或删除更高级或特定的规则。 在运行通过终端输入的规则之前，UFW 将运行一个文件 <code>before.rules</code>，它允许回环接口、ping 和 DHCP 等服务。要添加或改变这些规则，编辑 <code>/etc/ufw/before.rules</code> 这个文件。 同一目录中的 <code>before6.rules</code> 文件用于 IPv6 。</p><p>还存在一个 <code>after.rule</code> 和 <code>after6.rule</code> 文件，用于添加在 UFW 运行通过命令行输入的规则之后需要添加的任何规则。</p><p>还有一个配置文件位于 <code>/etc/default/ufw</code>。 从此处可以禁用或启用 IPv6，可以设置默认规则，并可以设置 UFW 以管理内置防火墙链。</p><h3 id="UFW-状态"><a href="#UFW-状态" class="headerlink" title="UFW 状态"></a>UFW 状态</h3><p>可以在任何时候使用命令：<code>sudo ufw status</code> 查看 UFW 的状态。这会显示所有规则列表，以及 UFW 是否处于激活状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status: active</span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">22                         ALLOW       Anywhere</span><br><span class="line">80&#x2F;tcp                     ALLOW       Anywhere</span><br><span class="line">443                        ALLOW       Anywhere</span><br><span class="line">22 (v6)                    ALLOW       Anywhere (v6)</span><br><span class="line">80&#x2F;tcp (v6)                ALLOW       Anywhere (v6)</span><br><span class="line">443 (v6)                   ALLOW       Anywhere (v6)</span><br></pre></td></tr></table></figure><h3 id="启用防火墙"><a href="#启用防火墙" class="headerlink" title="启用防火墙"></a>启用防火墙</h3><p>随着选择规则完成，初始运行 <code>ufw status</code> 可能会输出 <code>Status: inactive</code>。 启用 UFW 并强制执行防火墙规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure><p>禁用 UFW 规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw <span class="built_in">disable</span></span><br></pre></td></tr></table></figure><h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p>可以用下面的命令启动日志记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw logging on</span><br></pre></td></tr></table></figure><p>可以通过运行 <code>sudo ufw logging low|medium|high</code> 设计日志级别，可以选择 <code>low</code>、 <code>medium</code> 或者 <code>high</code>。默认级别是 <code>low</code>。</p><p>常规日志类似于下面这样，位于 <code>/var/logs/ufw</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sep 16 15:08:14 &lt;hostname&gt; kernel: [UFW BLOCK] IN&#x3D;eth0 OUT&#x3D; MAC&#x3D;00:00:00:00:00:00:00:00:00:00:00:00:00:00 SRC&#x3D;123.45.67.89 DST&#x3D;987.65.43.21 LEN&#x3D;40 TOS&#x3D;0x00 PREC&#x3D;0x00 TTL&#x3D;249 ID&#x3D;8475 PROTO&#x3D;TCP SPT&#x3D;48247 DPT&#x3D;22 WINDOW&#x3D;1024 RES&#x3D;0x00 SYN URGP&#x3D;0</span><br></pre></td></tr></table></figure><p>前面的值列出了服务器的日期、时间、主机名。剩下的重要信息包括：</p><ul><li>[UFW BLOCK]：这是记录事件的描述开始的位置。在此例中，它表示阻止了连接。</li><li>IN：如果它包含一个值，那么代表该事件是传入事件</li><li>OUT：如果它包含一个值，那么代表事件是传出事件</li><li>MAC：目的地和源 MAC 地址的组合</li><li>SRC：包源的 IP</li><li>DST：包目的地的 IP</li><li>LEN：数据包长度</li><li>TTL：数据包 TTL，或称为 time to live。 在找到目的地之前，它将在路由器之间跳跃，直到它过期。</li><li>PROTO：数据包的协议</li><li>SPT：包的源端口</li><li>DPT：包的目标端口</li><li>WINDOW：发送方可以接收的数据包的大小</li><li>SYN URGP：指示是否需要三次握手。 <code>0</code> 表示不需要。</li></ul>]]></content>
      
      
      <categories>
          
          <category> ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> firewall </tag>
            
            <tag> ubuntu </tag>
            
            <tag> debian </tag>
            
            <tag> arch </tag>
            
            <tag> ufw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 配置文件中如何正确的将变量用于 URL</title>
      <link href="/2017/04/26/nginx-resolver/"/>
      <url>/2017/04/26/nginx-resolver/</url>
      
        <content type="html"><![CDATA[<p>在 Nginx 配置文件中使用变量来存放一个http地址时，如果这个地址是域名而不是IP，如下所示：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">set</span> <span class="variable">$server_domain</span> <span class="string">"http://yourdomain:8080"</span>;</span><br><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /api &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> <span class="variable">$server_domain</span>;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/api/?(.*)$</span> <span class="string">"/<span class="variable">$1</span>"</span> <span class="literal">break</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host       <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP  <span class="variable">$remote_addr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置中的代理是会出错的，错误信息是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no resolver defined to resolve yourdomain</span><br></pre></td></tr></table></figure><p>但是如果我们不申明变量 $server_domain，而是直接设置 proxy_pass</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /api &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://yourdomain:8080;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/api/?(.*)$</span> <span class="string">"/<span class="variable">$1</span>"</span> <span class="literal">break</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host       <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP  <span class="variable">$remote_addr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候代理就会生效，毫无问题</p><p>原因是 Nginx 0.6.18以后的版本中启用了一个resolver指令，在使用变量来构造某个server地址的时候一定要用resolver指令来指定DNS服务器的地址，所以解决这个问题的方法很简单：在nginx的配置文件中的http{}部分添加一行DNS地址即可</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">resolver</span> <span class="number">8.8.8.8</span>;</span><br></pre></td></tr></table></figure><p>此外，如果有ipv6环境的机器，还可以加上ipv6=off指令，避免一些奇葩原因导致的no resolver defined to resolve错误。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">resolver</span> <span class="number">8.8.8.8</span> ipv6=<span class="literal">off</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为多个 Github 仓库配置配置不同的 SSH Key</title>
      <link href="/2017/04/03/mutli-ssh-keys-for-github/"/>
      <url>/2017/04/03/mutli-ssh-keys-for-github/</url>
      
        <content type="html"><![CDATA[<p>同一个电脑上多个账号访问 Github 仓库可以使用 ssh config 搞定，不过为了区分不同的账号需要修改主机名；</p><p>这里分享一个方便的方法，在已经克隆到代码的情况下，修改本地项目的 git 配置文件，为项目配置独立的 ssh key；</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># .&#x2F;.git&#x2F;config</span><br><span class="line">[user]</span><br><span class="line">        email &#x3D; ……</span><br><span class="line">        name &#x3D; ……</span><br><span class="line">[core]</span><br><span class="line">        repositoryformatversion &#x3D; 0</span><br><span class="line">        filemode &#x3D; false</span><br><span class="line">        bare &#x3D; false</span><br><span class="line">        logallrefupdates &#x3D; true</span><br><span class="line">        ignorecase &#x3D; true</span><br><span class="line">        sshCommand &#x3D; ssh -i ~&#x2F;.ssh&#x2F;your_key_file_name -F &#x2F;dev&#x2F;null  # 就是这句了</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">        url &#x3D;  ……</span><br><span class="line">        fetch &#x3D;  ……</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">        remote &#x3D; origin</span><br><span class="line">        merge &#x3D; refs&#x2F;heads&#x2F;master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Systemctl 指令</title>
      <link href="/2017/03/02/systemctl-helper/"/>
      <url>/2017/03/02/systemctl-helper/</url>
      
        <content type="html"><![CDATA[<p>Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。</p><p>Systemd 包含众多指令，本文重点介绍常用的 <code>systemctl</code> 指令。</p><h3 id="一、守护进程"><a href="#一、守护进程" class="headerlink" title="一、守护进程"></a>一、守护进程</h3><p>曾经 Linux 的启动一直是采用的 init 进程，使用如下指令来启动服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/apache2 start</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ service apache2 start</span><br></pre></td></tr></table></figure><p>这种方法有两个缺点：</p><ol><li>启动时间长<blockquote><p>init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</p></blockquote></li><li>启动脚本复杂<blockquote><p>init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</p></blockquote></li></ol><h3 id="二、Systemd"><a href="#二、Systemd" class="headerlink" title="二、Systemd"></a>二、Systemd</h3><p>为了解决上述两个问题，诞生了 Systemd。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。</p><p>根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要 <strong>守护整个系统</strong>。</p><p>使用了 Systemd，就不需要再用init了。Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。</p><blockquote><p>Systemd 并不是一个指令，而是一组指令，涉及到系统管理的各个方面。</p></blockquote><p>接下来就是本文主要介绍的 <code>systemctl</code> 指令。</p><h3 id="三、systemctl"><a href="#三、systemctl" class="headerlink" title="三、systemctl"></a>三、systemctl</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看服务列表</span></span><br><span class="line">systemctl list-units --<span class="built_in">type</span>=service </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有已经安装的 服务及状态（可为人所读, 内容简略、清晰）</span></span><br><span class="line">systemctl list-unit-files</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出正在运行的服务状态(基本不为人所读，内容复杂、全面)</span></span><br><span class="line">systemctl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以树形列出正在运行的进程，它可以递归显示控制组内容</span></span><br><span class="line">systemd-cgls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl start name.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">systemctl stop name.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">systemctl restart name.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">systemctl status name.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> name.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消开机自启</span></span><br><span class="line">systemctl <span class="built_in">disable</span> name.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否开机自启</span></span><br><span class="line">systemctl is-enabled postfix.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已启动的服务列表</span></span><br><span class="line">systemctl list-unit-files | grep enabled</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看启动失败的服务列表</span></span><br><span class="line">systemctl --failed</span><br></pre></td></tr></table></figure><p><em>使用指令 <code>systemctl is-enabled postfix.service</code> 得到的值可以是enable、disable或static，这里的 static 它是指对应的 Unit 文件中没有定义[Install]区域，因此无法配置为开机启动服务。</em></p><p>启用服务就是在当前“runlevel”的配置文件目录 <code>/etc/systemd/system/multi-user.target.wants</code> 里建立 <code>/usr/lib/systemd/system</code> 里面对应服务配置文件的软链接，禁用服务就是删除此软链接，添加服务就是添加软连接。</p>]]></content>
      
      
      <categories>
          
          <category> ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> systemd </tag>
            
            <tag> systemctl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 正确设置 default_server 避免恶意解析和IP访问</title>
      <link href="/2016/09/16/nginx-default-server/"/>
      <url>/2016/09/16/nginx-default-server/</url>
      
        <content type="html"><![CDATA[<h3 id="Nginx-默认-Server"><a href="#Nginx-默认-Server" class="headerlink" title="Nginx 默认 Server"></a>Nginx 默认 Server</h3><p>默认情况下 nginx 的 default_server 指令可以处理没有匹配到 server_name 的请求，如果没有显式定义 default_server，则 nginx 会选取第一个定义的 server 作为 default_server。</p><a id="more"></a><h3 id="默认-Server-存在的问题"><a href="#默认-Server-存在的问题" class="headerlink" title="默认 Server 存在的问题"></a>默认 Server 存在的问题</h3><p>这样的规则会导致两个问题：</p><ol><li>当有任何域名解析到我们的服务器，我们的 default_server 都会处理它，如果我们没有设置 default_server 则我们的第一个 server 会处理这些域名，无论这些 server 是否绑定 server_name；</li><li>如果我们没有绑定 IP 到 server，当使用 IP 访问我们的服务器时，也会被 default_server 处理；</li></ol><p>这两个问题会带来什么样的灾难，大家都明白，这里就不再赘述了；</p><h3 id="如何规避默认-Server-带来的问题"><a href="#如何规避默认-Server-带来的问题" class="headerlink" title="如何规避默认 Server 带来的问题"></a>如何规避默认 Server 带来的问题</h3><h4 id="取消-80-端口的-default-server"><a href="#取消-80-端口的-default-server" class="headerlink" title="取消 80 端口的 default_server"></a>取消 80 端口的 default_server</h4><p>解决默认 Server 最简单的办法就是取消默认 Server 就行了；</p><p>但是 nginx 中我们无法取消，因为不显示申明，也会默认第一个 Server 作为隐式申明</p><p>既然不能取消，那我们就只能修改默认 Server 的表现行为了；</p><p>我们可以通过如下配置，让 default_server 直接返回 444 状态；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    server_name _;</span><br><span class="line">    return 444;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>444 No Response</p><p>Nginx上HTTP服务器扩展。服务器不向客户端返回任何信息，并关闭连接（有助于阻止恶意软件）。</p></blockquote><h4 id="取消-443-端口的-default-server"><a href="#取消-443-端口的-default-server" class="headerlink" title="取消 443 端口的 default_server"></a>取消 443 端口的 default_server</h4><p>由于 443 需要 ssl 证书，所以还需要再 80 的配置上增加关于 ssl 的配置；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 default_server;</span><br><span class="line">    server_name _;</span><br><span class="line"></span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;nginx.crt;       # 证书配置</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;nginx.key;   # 证书配置</span><br><span class="line"></span><br><span class="line">    return 444;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述配置中的证书配置可以采用任意证书，因为我们本就不会处理匹配的请求，所以不需要正确的证书来获取浏览器的信任，但是 nginx 的 443 端口 server 又必须配置 ssl 证书，所以这里我们自己生成一个证书就可以了，不建议使用自有的真实证书，这会暴露域名；</p><p>生成证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/nginx/ssl/nginx.key -out /etc/nginx/ssl/nginx.crt</span><br></pre></td></tr></table></figure><h3 id="HTTP-自动跳转到-HTTPS"><a href="#HTTP-自动跳转到-HTTPS" class="headerlink" title="HTTP 自动跳转到 HTTPS"></a>HTTP 自动跳转到 HTTPS</h3><p>有时候我们需要使用 default_server 为我们带来便利，例如：实际网站的 server 中仅配置 443 端口，80 端口的请求统一跳转到对应的 443 服务；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    server_name _;</span><br><span class="line">    return 301 https:&#x2F;&#x2F;$host$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这时候，未受理的域名和ip访问均会跳转到 443 端口，我们只需要对 443 的默认 Server 输出 HTTP Status 444 就行了；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 default_server;</span><br><span class="line">    server_name _;</span><br><span class="line"></span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;nginx.crt;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;nginx.key;</span><br><span class="line"></span><br><span class="line">    return 444;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整配置"><a href="#完整配置" class="headerlink" title="完整配置"></a>完整配置</h3><h4 id="不自动强制-HTTPS"><a href="#不自动强制-HTTPS" class="headerlink" title="不自动强制 HTTPS"></a>不自动强制 HTTPS</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    server_name _;</span><br><span class="line">    return 444;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 default_server;</span><br><span class="line">    server_name _;</span><br><span class="line"></span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;nginx.crt;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;nginx.key;</span><br><span class="line"></span><br><span class="line">    return 444;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="需要-HTTP-自动跳转到-HTTPS"><a href="#需要-HTTP-自动跳转到-HTTPS" class="headerlink" title="需要 HTTP 自动跳转到 HTTPS"></a>需要 HTTP 自动跳转到 HTTPS</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    server_name _;</span><br><span class="line">    return 301 https:&#x2F;&#x2F;$host$request_uri;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 default_server;</span><br><span class="line">    server_name _;</span><br><span class="line"></span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;nginx.crt;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;nginx.key;</span><br><span class="line"></span><br><span class="line">    return 444;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过 Github gists 学习优秀的代码片段</title>
      <link href="/2016/06/20/create-ss-server/"/>
      <url>/2016/06/20/create-ss-server/</url>
      
        <content type="html"><![CDATA[<p>由于 Github gists 在国内无法正常访问，所以本文旨在快速学习Linux<del>搭建 <a href="https://github.com/shadowsocks/shadowsocks" target="_blank" rel="noopener">shadowsocks</a> 服务(以下简称ss)</del>，并利用 <a href="https://github.com/google/bbr" target="_blank" rel="noopener" title="bbr">bbr</a> 和 <a href="https://github.com/skywind3000/kcp" target="_blank" rel="noopener" title="kcp">kcp</a> 进行加速，然后在 windows/ios 设备上访问 Github gists 来学习优秀的代码片段。</p><p><strong>注意：本文基于你对 linux 操作系统有简单的认知和理解，所以本文并不适合纯小白</strong></p><p><strong>以下是需要用到的资源</strong></p><ul><li>一台可访国际互联网的服务器</li><li>ss 服务端一键安装脚本：<a href="https://github.com/flyzy2005/ss-fly" target="_blank" rel="noopener" title="ss-fly">ss-fly</a></li><li>kcptun 服务端：<a href="https://github.com/xtaci/kcptun" target="_blank" rel="noopener" title="kcptun">kcptun</a>（非必须）</li><li>kcptun 客户端：<a href="https://github.com/xtaci/kcptun" target="_blank" rel="noopener" title="kcptun">kcptun</a>（非必须)</li><li>ss windows 客户端：<a href="https://github.com/shadowsocks/shadowsocks-windows" target="_blank" rel="noopener" title="shadowsocks windows">shadowsocks-windows</a></li><li>ss ios 客户端：<a href="https://itunes.apple.com/us/app/potatso-lite/id1239860606?mt=8" target="_blank" rel="noopener" title="potatso lite">potatso lite</a></li></ul><h3 id="一、-获取服务器"><a href="#一、-获取服务器" class="headerlink" title="一、 获取服务器"></a>一、 获取服务器</h3><p>选购一台<strong>廉价</strong>的海外服务器就足够了，本文使用 <a href="https://www.vultr.com/?ref=8030646-4F" target="_blank" rel="noopener" title="vultr">vultr</a> 提供的 vps，目前最便宜的是$3.5一个月。使用下面的推广链接可获得$50首冲赠送。</p><p>推广链接：<a href="https://www.vultr.com/?ref=8030646-4F" target="_blank" rel="noopener">https://www.vultr.com/?ref=8030646-4F</a></p><p><em>注意：推广活动是限时的，如果点击过去发现无效，就表示活动过期了。</em></p><h3 id="二、-安装ss服务端"><a href="#二、-安装ss服务端" class="headerlink" title="二、 安装ss服务端"></a>二、 安装ss服务端</h3><p>服务端的安装方式有很多，本文选用 <a href="https://github.com/flyzy2005" target="_blank" rel="noopener">@flyzy2005</a> 编写的 <a href="https://github.com/flyzy2005/ss-fly" target="_blank" rel="noopener" title="ss-fly">ss-fly</a> 一键安装脚本。</p><h4 id="第一步：clone代码到本地"><a href="#第一步：clone代码到本地" class="headerlink" title="第一步：clone代码到本地"></a>第一步：clone代码到本地</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;flyzy2005&#x2F;ss-fly</span><br></pre></td></tr></table></figure><h4 id="第二步：运行安装脚本"><a href="#第二步：运行安装脚本" class="headerlink" title="第二步：运行安装脚本"></a>第二步：运行安装脚本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-fly&#x2F;ss-fly.sh -i yourpassword 8080</span><br></pre></td></tr></table></figure><p>其中<code>yourpassword</code>是 ss 连接密码，<code>8080</code>是端口号。</p><p>等待安装完成即可，安装完成之后服务会自动运行，并会开机自启。</p><p>如果需要修改密码或者端口，只需要<strong>重新运行一次安装脚本</strong>，或者直接修改<code>/etc/shadowsocks.json</code>这个配置文件。</p><p>相关操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ss-fly start        <span class="comment"># 启动</span></span><br><span class="line">/etc/init.d/ss-fly stop         <span class="comment"># 停止</span></span><br><span class="line">/etc/init.d/ss-fly restart      <span class="comment"># 重启</span></span><br><span class="line">/etc/init.d/ss-fly status       <span class="comment"># 查看状态</span></span><br><span class="line">ss-fly/ss-fly.sh -sslink        <span class="comment"># 查看连接</span></span><br><span class="line">vi /etc/shadowsocks.json        <span class="comment"># 修改配置</span></span><br></pre></td></tr></table></figure><h4 id="第三步：验证服务状态"><a href="#第三步：验证服务状态" class="headerlink" title="第三步：验证服务状态"></a>第三步：验证服务状态</h4><p>这一步并不是必须的，而是为了检查 ss 服务是否在<strong>正常运行</strong>，并<strong>能被外部网络访问</strong></p><h5 id="在服务器上执行"><a href="#在服务器上执行" class="headerlink" title="在服务器上执行"></a>在服务器上执行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -lntup</span><br></pre></td></tr></table></figure><p>检查输出结果是否有一个被 python 监听的<code>8080</code>端口，如果有就说明 ss 服务已经启动。</p><h5 id="在本地执行"><a href="#在本地执行" class="headerlink" title="在本地执行"></a>在本地执行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet yourserverip 8080</span><br></pre></td></tr></table></figure><p>其中<code>yourserverip</code>是你的服务器 ip，如果连接成功，就表示 ss 服务已经能被外部网络访问。</p><p>如果没有<code>telnet</code>这个命令，可以在<code>控制面板 &gt; 程序和功能 &gt; 启用或关闭 Windows 功能</code>中勾选<code>Telnet Client</code>并安装。</p><p>如果<code>telnet</code>连接失败，可以检查以下几个方面：</p><ol><li>服务器防火墙是否开放<code>8080</code>端口（<a href="https://github.com/flyzy2005/ss-fly" target="_blank" rel="noopener" title="ss-fly">ss-fly</a> 在安装过程中会自动配置防火墙开放<code>8080</code>）；</li><li>服务器提供商的防火墙策略是否开放<code>8080</code>（<a href="https://www.vultr.com/?ref=8030646-4F" target="_blank" rel="noopener" title="vultr">vultr</a> 默认无防火墙）；</li><li>你所在的网络是否允许访问<code>8080</code>，由于一些企业的防火墙策略只允许访问常用端口，所以本文使用的是<code>8080</code>这种比较常用的端口；</li></ol><h3 id="三、-安装SS客户端"><a href="#三、-安装SS客户端" class="headerlink" title="三、 安装SS客户端"></a>三、 安装SS客户端</h3><p>ss 客户端也有很多，本文选用 <a href="https://github.com/shadowsocks/shadowsocks-windows" target="_blank" rel="noopener" title="shadowsocks windows">shadowsocks-windows</a>，使用方法非常简单，填写好<code>服务器地址``服务器端口``密码</code>就可以正常使用了，记得更新PAC配置。</p><p><strong>到这里，ss 服务端和 windows 客户端就已经安装完成了，已经可以正常的网上冲浪了。</strong></p><p>如果你觉得冲浪的速度有点差强人意，那么你可以继续进行下面的步骤。</p><h3 id="四、-开启BBR加速"><a href="#四、-开启BBR加速" class="headerlink" title="四、 开启BBR加速"></a>四、 开启BBR加速</h3><p><a href="https://github.com/google/bbr" target="_blank" rel="noopener" title="bbr">bbr</a> 是 <a href="https://github.com/google" target="_blank" rel="noopener">@google</a> 开源的一套内核加速算法，可以让你搭建的 shadowsocks 速度上一个台阶。</p><p>本文使用的<code>ss-fly</code>一键安装脚本已经集成了<code>bbr</code>的一键安装，所以我们只需要在服务器上运行以下脚本就可以开启<code>bbr</code>加速了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-fly&#x2F;ss-fly.sh -bbr</span><br></pre></td></tr></table></figure><p><strong>注意：安装完成之后需要重启系统才能生效。</strong></p><p>检测<code>bbr</code>加速是否开启，可以输入以下脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure><p>如果返回类似以下这种<strong>后面含有<code>bbr</code></strong>的内容，则说明已经成功开启了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_available_congestion_control &#x3D; bbr cubic reno</span><br></pre></td></tr></table></figure><p><strong>到这里，你不但完成了 ss 服务端和 windows 客户端的安装，还对服务端的 ss 进行了 bbr 加速。</strong></p><p>这基本能满足大多数冲浪需求了，但如果你像本文一样，购买的是非常廉价而且又远在美利坚的 vps，每到晚上速度就会慢得让人接受不了，那么你可以继续下面的步骤。</p><h3 id="五、-使用KCPTUN进行加速"><a href="#五、-使用KCPTUN进行加速" class="headerlink" title="五、 使用KCPTUN进行加速"></a>五、 使用KCPTUN进行加速</h3><p><a href="https://github.com/xtaci/kcptun" target="_blank" rel="noopener" title="kcptun">kcptun</a> 是由 <a href="https://github.com/xtaci" target="_blank" rel="noopener">@xtaci</a> 基于 <a href="https://github.com/skywind3000/kcp" target="_blank" rel="noopener" title="kcp">kcp</a> 协议的<code>golang</code>实现。KCP是一个快速可靠协议，能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。</p><p><strong>注意：使用<code>kcptun</code>会增加流量的开支</strong></p><p>但是对于本文中使用的 <a href="https://www.vultr.com/?ref=8030646-4F" target="_blank" rel="noopener" title="vultr">vultr</a> vps 最低配，也就是 500G/month 的流量限制，完全能够负担。</p><h4 id="下载最新版的kcptun"><a href="#下载最新版的kcptun" class="headerlink" title="下载最新版的kcptun"></a>下载最新版的kcptun</h4><p>打开 <a href="https://github.com/xtaci/kcptun/releases" target="_blank" rel="noopener">https://github.com/xtaci/kcptun/releases</a> 在服务器上下载最新版的<code>kcptun</code>服务端<code>kcptun-linux-amd64-20xxxxxx.tar.gz</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 本文使用的 v20190418</span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;xtaci&#x2F;kcptun&#x2F;releases&#x2F;download&#x2F;v20190418&#x2F;kcptun-linux-amd64-20190418.tar.gz</span><br></pre></td></tr></table></figure><p>解压之后启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;server_linux_amd64 -t &quot;yourssip:8080&quot; -l &quot;:8081&quot; -mode fast3 -nocomp -sockbuf 16777217 -dscp 46 --key yourpassword</span><br><span class="line"># 这里是直接在当前服务器会话运行的，你可以使用 nohup 让它在后台运行，也可以注册成 systemd 服务让它以服务的形式启动</span><br></pre></td></tr></table></figure><p>其中<code>yourssip</code>是你的 ss 服务器 ip，在本文中 ss 和 kcptun 部署在同一服务器，所以这里直接填写服务器的 ip 地址，<code>8080</code>是你的 ss 端口，<code>8081</code>是你准备让<code>kcptun</code>监听的端口，<code>yourpassword</code>是你的<code>kcptun</code>密码。</p><p>你任然可以使用<code>netstat -lntup</code>来查看<code>8081</code>端口的监听情况，以便确认<code>kcptun</code>是否启动成功</p><p><strong>这样，kcptun 服务端就已经部署好了</strong></p><p>接下来下载最新版的 windows 客户端<code>kcptun-windows-amd64-20xxxxxx.tar.gz</code>，解压之后会发现里面包含 windows 服务端和客户端文件，由于我们的服务端已经部署在 linux 上，所以我们只需要名为<code>client_windows_amd64.exe</code>的客户端文件。</p><p>我们用<code>cmd</code>运行以下脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client_windows_amd64.exe -r &quot;KCP_SERVER_IP:8081&quot; -l &quot;:1000&quot; -mode fast3 -nocomp -sockbuf 16777217 -dscp 46 --key yourpassword</span><br></pre></td></tr></table></figure><p>其中<code>KCP_SERVER_IP</code>是你的<code>kcptun</code>所在服务器的 ip，<code>8081</code>是你的<code>kcptun</code>监听的端口，<code>:1000</code>是你的<code>kcptun</code>客户端准备监听的本地端口，<code>yourpassword</code>是你的<code>kcptun</code>密码。</p><p>这样我们的<code>kcptun</code>客户端就已经成功连接到了我们的<code>kcptun</code>服务端，接下来我们只需要修改一下我们的<code>shadowsocks-windows</code>客户端的配置，让<code>shadowsocks-windows</code>不把数据发送到 ss 服务器，而是把数据发送到本地的<code>kcptun</code>，就能实现我们的<code>kcptun</code>加速了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#   ss客户端 -&gt; kcptun客户端 -&gt; kcptun服务端 -&gt; ss服务端</span><br></pre></td></tr></table></figure><p><strong>shadowsocks-windows 配置修改</strong></p><p>将<code>服务器地址</code>改为<code>127.0.0.1</code>，将<code>服务器端口</code>改为<code>1000</code>，确认之后就可以享受<code>kcptun</code>加速带来的稳定和快乐了。</p><h3 id="六、整合shadowsocks-windows和kcptun客户端"><a href="#六、整合shadowsocks-windows和kcptun客户端" class="headerlink" title="六、整合shadowsocks-windows和kcptun客户端"></a>六、整合shadowsocks-windows和kcptun客户端</h3><p>到上一步的时候，由于我们在客户端每次都要开启两个程序（kcptun客户端、ss客户端），所以在使用上显得并不那么优雅。好在<code>shadowsocks-windows</code>提供了插件的支持，我们可以把<code>kcptun</code>以插件的形式加载到<code>shadowsocks-windows</code>，使得我们只需要启动<code>shadowsocks-windows</code>就可以愉快的冲浪。</p><ol><li>复制<code>client_windows_amd64.exe</code>到<code>shadowsocks-windows</code>目录；</li><li>修改<code>shadowsocks-windows</code>配置，将<code>服务器地址</code>改为<code>ss服务器地址</code>，将<code>服务器端口</code>改为<code>8081</code>（服务端<code>kcptun</code>监听的端口），<code>插件程序</code>填写<code>client_windows_amd64.exe</code>，<code>插件参数</code>填写以下内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-r %SS_REMOTE_HOST%:%SS_REMOTE_PORT% -l %SS_LOCAL_HOST%:%SS_LOCAL_PORT% --mode fast3 --nocomp --sockbuf 16777217 --dscp 46 --key kcptunpassword</span><br><span class="line"># kcptunpassword 是你的 kcptun 密码</span><br></pre></td></tr></table></figure></li></ol><p>确认之后就可以享受<code>kcptun</code>加速带来的稳定和快乐了。</p><h3 id="七、-IOS客户端"><a href="#七、-IOS客户端" class="headerlink" title="七、 IOS客户端"></a>七、 IOS客户端</h3><p>国区已经没有好用的 ss 客户端了，本文使用的 <a href="https://itunes.apple.com/us/app/potatso-lite/id1239860606?mt=8" target="_blank" rel="noopener" title="potatso lite">potatso lite</a> 也需要在美区才能下载，关于如何切换美区，或者注册美区账号，以下提供简要的说明，避免大家踩坑<del>根本没有人会浏览到我的博客，哪儿来的大家</del>。</p><ol><li>需要能访问真正互联网的网络，推荐使用 <a href="https://www.nutsvpn.com/" target="_blank" rel="noopener">nuts</a> 的 ios 版；</li><li>不要用 wifi 代理，用代理无法访问 appstore；</li><li>需要一个美国身份的生成器，不要乱填，乱填无法通过验证，推荐使用 <a href="https://www.fakenamegenerator.com/gen-male-us-us.php" target="_blank" rel="noopener">fake name generator</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ladder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>令人惊叹的代码片段</title>
      <link href="/2016/01/12/awesome-code-snippet/"/>
      <url>/2016/01/12/awesome-code-snippet/</url>
      
        <content type="html"><![CDATA[<p>常年混迹 Github 以及各种社区，总能在其他开发者的代码中找到一些不可思议的代码片段，它们有的优雅高效，有的晦涩难懂，更有甚者让人大跌眼镜，今天就和大家分享一波「令人惊叹的代码片段」。</p><a id="more"></a><h3 id="一、单行写一个评分组件"><a href="#一、单行写一个评分组件" class="headerlink" title="一、单行写一个评分组件"></a>一、单行写一个评分组件</h3><p>利用数组提供的 <code>slice</code> 函数对字符串（即字符数组）进行截取，简单到不可思议，让人大呼 <strong>“我怎么没想到”</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'★★★★★☆☆☆☆☆'</span>.slice(<span class="number">5</span> - rate, <span class="number">10</span> - rate);</span><br></pre></td></tr></table></figure><p>演示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rate = <span class="number">1</span>;</span><br><span class="line"><span class="string">'★★★★★☆☆☆☆☆'</span>.slice(<span class="number">5</span> - rate, <span class="number">10</span> - rate);</span><br><span class="line"><span class="comment">// "★☆☆☆☆"</span></span><br><span class="line">rate = <span class="number">2</span>;</span><br><span class="line"><span class="string">'★★★★★☆☆☆☆☆'</span>.slice(<span class="number">5</span> - rate, <span class="number">10</span> - rate);</span><br><span class="line"><span class="comment">// "★★☆☆☆"</span></span><br><span class="line">rate = <span class="number">3</span>;</span><br><span class="line"><span class="string">'★★★★★☆☆☆☆☆'</span>.slice(<span class="number">5</span> - rate, <span class="number">10</span> - rate);</span><br><span class="line"><span class="comment">// "★★★☆☆"</span></span><br><span class="line">rate = <span class="number">4</span>;</span><br><span class="line"><span class="string">'★★★★★☆☆☆☆☆'</span>.slice(<span class="number">5</span> - rate, <span class="number">10</span> - rate);</span><br><span class="line"><span class="comment">// "★★★★☆"</span></span><br><span class="line">rate = <span class="number">5</span>;</span><br><span class="line"><span class="string">'★★★★★☆☆☆☆☆'</span>.slice(<span class="number">5</span> - rate, <span class="number">10</span> - rate);</span><br><span class="line"><span class="comment">// "★★★★★"</span></span><br></pre></td></tr></table></figure><h3 id="二、两句代码实现笛卡尔积"><a href="#二、两句代码实现笛卡尔积" class="headerlink" title="二、两句代码实现笛卡尔积"></a>二、两句代码实现笛卡尔积</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = [</span><br><span class="line">  [<span class="string">'红'</span>, <span class="string">'黄'</span>, <span class="string">'蓝'</span>],</span><br><span class="line">  [<span class="string">'64G'</span>, <span class="string">'128G'</span>, <span class="string">'256G'</span>],</span><br><span class="line">  [<span class="string">'30kg'</span>, <span class="string">'100kg'</span>, <span class="string">'5kg'</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cartesianProduct = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> prev.reduce(<span class="function">(<span class="params">result, p</span>) =&gt;</span> [...result, ...next.map(<span class="function"><span class="params">n</span> =&gt;</span> p + n)], [])</span><br><span class="line"><span class="keyword">const</span> r = source.reduce(<span class="function">(<span class="params">result, item, i</span>) =&gt;</span> (i &gt; <span class="number">0</span> ? cartesianProduct(result, item) : result), source[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r)</span><br></pre></td></tr></table></figure><p><a href="https://baiyezi.com/2020/09/01/cartesian-product/">查看代码解析&gt;&gt;</a></p><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/662/cdn-blog/post/2020-09-02-09-41-50.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code snippet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>令人惊叹的正则表达式实例</title>
      <link href="/2016/01/03/awesome-regexp/"/>
      <url>/2016/01/03/awesome-regexp/</url>
      
        <content type="html"><![CDATA[<p>正则表达式在处理文本方面具有天然优势，但受限于它的可读性和可编程性，我们总会在写出一长串正则表达式后怀疑它是否能如期表现，进而对它进行一系列测试和校验。</p><p>本着 <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener">DRY</a> 原则，我把曾经用过或学习过的一些优秀的正则表达式整理汇总，记录自己的同时也分享给大家，希望能帮到各位望着正则表达式头皮发麻的同学们。</p><p>我相信，总有一款会让你喊出“卧槽”。</p><a id="more"></a><h3 id="一、正则表达式为数字添加千分符"><a href="#一、正则表达式为数字添加千分符" class="headerlink" title="一、正则表达式为数字添加千分符"></a>一、正则表达式为数字添加千分符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\B(?=(\d&#123;<span class="number">3</span>&#125;)+\b)/;</span><br></pre></td></tr></table></figure><ol><li>查找一个“非单词边界”</li><li>[1]后面伴随着“3 的倍数个数字”</li><li>[2]后面伴随着一个“单词边界”</li></ol><p>把查找到的“非单词边界”替换成千分符即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'32132112345123136.123'</span>.replace(<span class="regexp">/\B(?=(\d&#123;3&#125;)+\b)/g</span>, <span class="string">','</span>);</span><br><span class="line">(<span class="string">'32,132,112,345,123,136.123'</span>);</span><br></pre></td></tr></table></figure><p>缺陷：<strong>小数位同样会被处理</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'32132112345123136.123123123123'</span>.replace(<span class="regexp">/\B(?=(\d&#123;3&#125;)+\b)/g</span>, <span class="string">','</span>);</span><br><span class="line">(<span class="string">'32,132,112,345,123,136.123,123,123,123'</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> regexp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
